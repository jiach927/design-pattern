## 原型模式 Prototype Pattern

### 定义

使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

原型模式是一种对象创建型模式。

### 工作原理

将一个原型对象传给要发起创建的对象，要发起创建的对象通过请求原型对象拷贝自己来实现创建过程。

创建克隆对象的工厂是原型类，工厂方法就是克隆方法。

通过克隆创建的对象是全新的对象，拥有新的内存地址，每一个克隆对象相互独立。

### 角色

1.Prototype:抽象原型类，声明克隆方法，是所有具体原型类的父类

2.ConcretePrototype:具体原型类，实现在抽象原型类中声明的克隆方法，返回自己的一个克隆对象

3.Client:让一个原型对象克隆自己从而创建新的对象

### 克隆方法

1.通用克隆方法

在具体原型类的clone()方法中实例化一个与自身类型相同的对象，传入相关参数再调用相关方法，返回新创建的对象。

2.java专有克隆方法

使用父类Object的clone()方法，需要具体原型类实现Cloneable接口允许复制（否则会抛出CloneNotSupportedException）。

克隆对象和原型对象不是同一个对象，内存地址不同，但是类型相同。

此时抽象原型类是Object类。

### Java中的数据类型

#### 值类型（基本数据类型）

int、double、byte、boolean、char等简单数据类型

#### 引用类型

类、接口、数组等复杂类型

### 浅克隆 ShallowClone

原型对象的成员变量是引用类型，将引用对象的地址复制一份给克隆对象，使原型对象和克隆对象使用同一个引用对象。

当对象被复制时，只复制它本身和其中包含的值类型的成员变量，引用类型的成员变量没有被复制。

覆盖Object类的clone()方法实现的是浅克隆。

原型对象和克隆对象的内存地址不同，原型对象==克隆对象为false

其引用对象是同一个，内存地址相同，原型对象引用成员变量==克隆对象引用成员变量为true

### 深克隆 DeepClone

对象本身和其包含的所有成员变量都会被复制。

实现方式是序列化等方式，将原有对象的拷贝写到流中，原有对象仍存在于内存中。

要求实现序列化的对象必须实现Serializable接口。

### 原型管理器 Prototype Manager

专门负责克隆对象的工厂，定义集合用于存储原型对象，需要克隆对象时通过复制集合中原型对象来实现。

### 优点

1.创建新的实例较为复杂时，使用原型模式可以简化创建过程，提高创建效率。

2.客户端针对抽象原型类编程，扩展性较好。

3.工厂类和产品类合二为一，提供了简化的创建结构。

4.可以使用深克隆保存对象的状态，以便在需要时使用，可辅助实现撤销操作。

### 优点

1.需要为每一个类配备一个克隆方法，对已有类改造时，需要修改源代码，不符合“开闭原则”。

2.为了实现深克隆，当对象之间有多层嵌套引用时，每一层对象对应的类需要支持深克隆，实现较为麻烦。

### 适用场景

1.创建新对象成本较大。

2.系统要保存对象状态，对象的状态变化很小/占用内存很少，可以使用原型+备忘录模式实现。

3.需要避免使用分层次的工厂类来创建分层次的对象，且类的实例对象只有一个/很少几个组合状态。