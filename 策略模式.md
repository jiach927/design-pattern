## 策略模式 Strategy Pattern

### 概述

在策略模式中，定义一些独立的类来封装不同的算法，每一个类封装一种具体的算法，封装算法的类称为策略。为了保证策略使用的一致性，一般提供一个抽象策略类定义规则，每种算法对应一个具体策略类。

策略模式将算法的定义放在专门的策略类中，使用算法的环境类针对抽象策略类进行编程，实现算法的定义与使用分开。

### 定义

策略模式定义一系列算法类，将每一个算法封装起来，并且让它们可以相互替换，让算法独立于使用它的客户而变化。

策略模式又称为政策模式，是一种对象行为型模式。

### 角色

1.Context:环境类，使用算法的角色，在解决某个问题时可以采用多种策略，维持对抽象策略类的引用，用于定义采用的策略。
```java
class Context{
    private AbstractStrategy strategy;
    public void setStrategy(AbstractStrategy strategy){
        this.strategy = strategy;
    }
    public void algorithm(){
        strategy.algorithm();
    }
}
```
2.Strategy:抽象策略类，为支持的算法声明抽象方法，是所有具体策略类的父类。
```java
abstract class AbstractStrategy{
    public abstract void algorithm();
}
```
3.ConcreteStrategy:具体策略类，实现在抽象策略类中声明的算法，运行时将覆盖在Context中定义的抽象策略类对象，使用具体算法实现业务处理。
```java
class ConcreteStrategyA extends AbstractStrategy{
    public void algorithm(){...};
}
```

### 应用场景

Java SE的容器布局管理、微软的演示项目PetShop。

### 优点

1.完美支持“开闭原则”，可以在不修改原有系统的基础上选择算法，也可以灵活增加新的算法。

2.提供了管理相关算法族的办法，策略类的等级结构定义了一个算法族，可以把公共代码移到抽象策略类中，避免代码重复。

3.避免创建环境类的子类来提供不同的算法，避免算法的定义和使用混合在一起。

4.避免多重条件选择语句，避免把采取哪一种算法的逻辑与算法本身的实现逻辑混合在一起，硬编码在庞大的多重条件选择语句中。

5.提供算法的复用机制，不同的环境类可以方便复用封装算法的策略类。

### 缺点

1.客户端必须知道所有的策略类，并自行决定使用哪一个策略类。

2.将造成系统产生很多的具体策略类，任何细小的变化都要增加一个具体策略类。

3.客户端每次只能使用一个具体策略类。

### 适用场景

1.一个系统需要动态地在几种算法中选择一种。

2.一个对象有很多的行为,使用多重选择语句难以维护。

3.不希望客户端知道复杂的、与算法相关的数据结构。在具体策略类中封装算法，可以提高算法的保密性与安全性。