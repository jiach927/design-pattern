## 工厂方法模式

### 定义

定义一个用于创建产品对象的接口，让子类决定将哪一个具体产品类实例化。

工厂方法模式提供一个抽象工厂接口来声明抽象工厂方法，其子类创建具体的产品对象。

工厂方法模式简称工厂模式，是类创建型模式。

### 角色

1.Product:抽象产品接口，是工厂方法模式创建对象的父类。

2.ConcreteProduct:具体产品类，实现抽象产品接口，由专门的具体工厂创建。

3.ConcreteFactory:具体工厂类，抽象工厂类的子类，实现抽象工厂中定义的工厂方法，可被客户端调用返回具体产品类的实例。

### Java反射机制

在程序运行时获取已知名称的类或已有对象的相关信息的一种机制，包括类的方法、属性、父类等信息，还包括实例的创建和实例类型的判断等。

#### 通过类名生成实例对象并返回

```java
Class c = Class.forName(className);
Object obj = c.newInstance();
return obj;
```

### 问题

1.工厂方法模式中工厂方法不能是静态方法。

```java
Factory factory =  new ConcreteFactory();
```

factory是Factory的实例，调用Factory的静态工厂方法，而其工厂方法为空，并不能创建具体产品类的对象；ConcreteFactory继承Factory类或实现Factory接口，重写的静态工厂方法和Factory的静态工厂方法是两个不同方法，factory只能调用后者。

2.可以在客户端代码中通过反射机制生成具体产品对象，增加具体产品类时只需将其作为抽象产品类的子类并修改配置文件，不需要抽象工厂类和具体工厂类。

上述做法是可行的，但是存在问题，反射机制直接生成具体产品对象缺少了初始化产品对象以及连接数据库、创建文件等对资源和环境进行配置等工作，而抽象工厂类和具体工厂类可以完成上述工作。

### 优点

1.客户端只需关心所需产品对应的工厂，无需关心创建细节，甚至无需知道具体产品类的类名。

2.基于工厂角色和产品角色的多态性设计，使工厂能够自主确定创建何种产品对象，创建细节完全封装在具体工厂内部。

3.在系统中加入新产品时，只需添加具体工厂类和具体产品类，完全符合“开闭原则”，
提升系统的可扩展性。

### 缺点

1.添加新产品时，具体工厂类和具体产品类需要编写，系统中类个数成对增加，一定程度增加系统复杂度，给系统带来额外开销。

2.引入抽象产品和抽象工厂，客户端使用抽象层进行定义，增加系统抽象性和理解难度；可能需要用到DOM(XML解析技术)、java反射等技术，增加系统的实现难度。

### 适用场景

1.客户端不知道所需产品对应的类

2.抽象工厂类通过子类指定创建哪些具体产品类的对象