## 工厂模式

工厂模式是创建型设计模式。

工厂模式包括简单工厂模式、工厂方法模式、抽象工厂模式。

## 简单工厂模式Simple Factory Pattern

### 基本流程

1.将需要创建的各种不同对象的相关代码封装到不同的类中，这些类称为具体产品类。
2.将它们的公共代码进行抽象和提取后封装在一个抽象产品类中，每一个具体产品类都是抽象产品类的子类。
3.提供一个工厂类，其中包括一个创建产品的工厂方法，该方法可以根据传入参数的不同创建具体的产品对象。
4.客户端需要调用工厂类的工厂方法并传入具体参数即可得到产品对象。

### 定义

定义一个工厂类，可以根据参数的不同返回不同类的实例，被创建的实例通常都有共同的父类。

简单工厂模式创建实例的方法是static方法，所以又称为静态工厂方法模式，属于类创建模式。

### 角色

1.Factory：简单工厂模式的核心;提供静态的工厂方法factoryMethod()负责创建所有产品实例，返回抽象产品类型Product；可直接被外界调用。

2.Product：工厂类创建的所有对象的父类，封装各种产品对象的公有方法。

3.ConcreteProduct：具体产品类，是简单工厂模式的创建目标，是Product子类且需要实现在Product中声明的方法。

### 优点

1.实现对象创建和使用的分离

工厂类可以决定什么时候创建哪一个具体产品类的实例，客户端不必直接创建产品对象而是消费产品对象。

2.一定程度减少客户端记忆量

客户端只需知道创建具体产品类对象所需的参数，无需知道类名。

3.一定程度提高系统灵活性

通过引入配置文件，可在不修改客户端代码的情况下修改和增加具体产品类。

### 缺点

1.工厂类集中所有产品的创建逻辑，一旦不能正常工作，整个系统受到影响。

2.增加工厂类，增加系统的复杂度和理解难度。

3.添加新产品需要修改工厂类逻辑，产品较多时工厂逻辑复杂，不利于系统维护和扩展。

4.使用静态工厂方法，造成工厂角色无法形成继承的等级结构。

**个人理解:继承时子类继承父类的静态方法，若新定义同名静态方法，则是两个静态方法;子类调用的静态方法就是父类的静态方法,不会copy**

### 适用场景

1.工厂类创建的对象比较少

2.客户端只关心传入工厂类的参数，不关心如何创建对象
