## 观察者模式 Observer Pattern

### 对象联动

一个对象状态或行为的变化将导致其他对象的状态或行为也发生改变，它们之间将产生联动。

### 概述

在观察者模式中，发生改变的对象称为观察目标，被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间可以没有任何相互联系。

### 定义

观察者模式定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。

观察者模式又称为发布-订阅模式，是一种对象行为型模式。

### 角色

1.Subject:被观察的对象，其中定义了一个观察者集合，提供一系列方法增加和删除观察者对象，同时定义通知方法notify()。
```java
abstract class Subject{
    //存储所有的观察者对象
    protected ArrayList Observers = new ArrayList();
    //向观察者集合中增加一个观察者
    public void attach(Observer observer){
        observers.add(observer);
    }
    //在观察者集合中删除一个观察者
    public void detach(Observer observer){
        observers.remove(observer);
    }
    //声明抽象通知方法
    public abstract void notify();
}
```
2.ConcreteSubject：具体目标，Subject子类，通常包含经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知。
```java
class ConcreteSubject extends Subject{
   //实现通知方法
   public void notify(){
       for(Object obj : observers)
          (Observer)obj.update();
   }
}
```
3.Observer:抽象观察者，对观察目标的改变做出反应，一般定义为接口，声明更新数据的方法update()。
```java
interface Observer{
    //声明响应方法
    public abstract void update();
}
```
4.ConcreteObserver:具体观察者，维护指向具体目标对象的引用；存储具体观察者的有关状态，这些状态需要和具体目标的状态一致；实现Observer中定义的update()方法。
```java
class ConcreteObserver implements Observer{
    //实现响应方法
    public void update(){...}
}
```

### 思考题

观察者模式是否符合“开闭原则”?

增加具体观察者时符合“开闭原则”，增加具体目标类时若具体观察者需要用到新增具体目标类的状态，则不符合“开闭原则”，反之符合“开闭原则”。

### JDK中对观察者模式的支持

java.util.Observer接口充当抽象观察者，java.uti.Observable类充当抽象观察目标类。

### Java事件处理

JDK 1.0和更早版本的事件处理模型是基于职责链模式的，JDK 1.1和以后的版本中事件处理模型采用基于观察者模式的委派事件模型DEM。

DEM模型是一个Java组件所引发的事件不由引发事件的对象自己来负责处理，而是委派给独立的事件处理对象负责的模型。

在DEM模型中，目标角色（事件源）负责发布事件，观察者角色（事件监听器）可以向目标订阅它所感兴趣的事件。当具体目标产生一个事件时，它将通知所有的订阅者。在这个过程中，可以通过事件对象传递与事件相关的信息。

Java事件处理模型的三要素：事件源对象、事件监听对象、事件对象。
