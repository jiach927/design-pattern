## 观察者模式 Observer Pattern

### 对象联动

一个对象状态或行为的变化将导致其他对象的状态或行为也发生改变，它们之间将产生联动。

### 概述

在观察者模式中，发生改变的对象称为观察目标，被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间可以没有任何相互联系。

### 定义

观察者模式定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。

观察者模式又称为发布-订阅模式，是一种对象行为型模式。

### 角色

1.Subject:被观察的对象，其中定义了一个观察者集合，提供一系列方法增加和删除观察者对象，同时定义通知方法notify()。
```java
abstract class Subject{
    //存储所有的观察者对象
    protected ArrayList Observers = new ArrayList();
    //向观察者集合中增加一个观察者
    public void attach(Observer observer){
        observers.add(observer);
    }
    //在观察者集合中删除一个观察者
    public void detach(Observer observer){
        observers.remove(observer);
    }
    //声明抽象通知方法
    public abstract void notify();
}
```
2.ConcreteSubject：具体目标，Subject子类，通常包含经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知。
```java
class ConcreteSubject extends Subject{
   //实现通知方法
   public void notify(){
       for(Object obj : observers)
          (Observer)obj.update();
   }
}
```
3.Observer:抽象观察者，对观察目标的改变做出反应，一般定义为接口，声明更新数据的方法update()。
```java
interface Observer{
    //声明响应方法
    public abstract void update();
}
```
4.ConcreteObserver:具体观察者，维护指向具体目标对象的引用；存储具体观察者的有关状态，这些状态需要和具体目标的状态一致；实现Observer中定义的update()方法。
```java
class ConcreteObserver implements Observer{
    //实现响应方法
    public void update(){...}
}
```

### 思考题

观察者模式是否符合“开闭原则”?

增加具体观察者时符合“开闭原则”，增加具体目标类时若具体观察者需要用到新增具体目标类的状态，则不符合“开闭原则”，反之符合“开闭原则”。

### JDK中对观察者模式的支持

java.util.Observer接口充当抽象观察者，java.uti.Observable类充当抽象观察目标类。

### Java事件处理

JDK 1.0和更早版本的事件处理模型是基于职责链模式的，JDK 1.1和以后的版本中事件处理模型采用基于观察者模式的委派事件模型DEM。

DEM模型是一个Java组件所引发的事件不由引发事件的对象自己来负责处理，而是委派给独立的事件处理对象负责的模型。

在DEM模型中，目标角色（事件源）负责发布事件，观察者角色（事件监听器）可以向目标订阅它所感兴趣的事件。当具体目标产生一个事件时，它将通知所有的订阅者。在这个过程中，可以通过事件对象传递与事件相关的信息。

Java事件处理模型的三要素：事件源对象、事件监听对象、事件对象。


### 观察者模式与MVC

MVC是一种架构模式，包含三个角色:模型Model、视图View和控制器Controller，其中模型可对应于观察者模式中的观察目标，而视图对应于观察者，控制器可以充当两者之间的中介者。

### 使用场景

编程语言的GUI事件处理、基于事件的XML解析技术(SAX2)、Web事件处理。

### 优点

1.观察者模式可以实现表现层和数据逻辑层的分离，定义稳定的消息更新传递机制，并且抽象了更新接口，使得可以有不同的表现层充当具体观察者。

2.观察者模式在观察目标和观察者之间建立一个抽象的耦合，在抽象观察目标类中定义了一个抽象观察者集合，无须了解其具体观察者。

3.观察者模式支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度。

4.观察者模式符合“开闭原则”，增加新的具体观察者无须修改原有代码，在具体观察者类和具体观察目标类之间无关联关系时，增加新的观察目标类也很方便。

### 缺点

1.如果一个观察目标对象有很多直接或间接的观察者，通知每个观察者很花费时间。

2.如果在观察者和观察目标之间存在循环依赖，观察目标会触发循环调用，可能导致系统崩溃。

3.观察者模式只能让观察者知道观察目标发生了变化，但是无法使其知道观察目标是怎么发生变化的。

### 适用场景

1.一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将它们独立封装使它们可以各自独立地改变和使用。

2.一个对象的改变将导致一个或多个其他对象也发生改变，不知道具体多少对象和哪些对象要发生改变。

3.创建触发链:A对象行为影响B对象，B对象行为影响C对象。