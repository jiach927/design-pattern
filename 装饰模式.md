## 装饰模式 Decorator Pattern

### 概述

装饰模式是一种用于替代继承的技术，通过无须定义子类的方式给对象动态增加职责，使用对象间的关联关系取代类之间的继承关系。

装饰模式引入装饰类，在装饰类中可以调用待装饰类的方法，也可以增加新方法来扩充带装饰类的功能。

### 定义

动态地给对象增加一些额外的职责，是对象结构型模式。

### 角色

1.Component:抽象构件，是ConcreteComponent和Decorator的父类，声明在具体构件中实现的业务方法，使客户端以一致的方式处理未被装饰的对象和装饰之后的对象，实现客户端的透明操作。

2.ConcreteComponent:具体构件，是抽象构件子类，实现在抽象构件中声明的方法，装饰器可以给它增加额外的职责。

3.Decorator:抽象装饰类，是抽象构件子类，用于给具体构件增加职责，具体职责在子类中实现。

引用抽象构件对象，调用装饰前构件对象的方法，通过Decorator子类扩展方法，达到装饰的目的。
```java
class Decorator implements Component{
    private Component component;
    public Decorator(Component component){
        this.component = component;
    }
    public void operation(){
        component.operation(); //调用原有业务方法
    }
}
```
4.ConcreteDecorator:具体装饰类，是抽象装饰类子类，负责添加新的职责，可以调用抽象装饰类中定义的方法，同时增加新的方法来扩充对象行为。
```java
class ConcreteDecorator extends Decorator{
    public ConcreteDecorator(Component c){
        super(c);
    }
    public void operation(){
        super.operation();
        addedBehavior(); //调用新增业务方法
    }
    public void addedBehavior(){} //新增业务方法
}
```

### 问题

1.能否在装饰模式中找出两个独立变化的维度? 

可以，一个是具体构件类，一个是具体装饰类。

2.比较装饰模式和桥接模式的异同有哪些?

相同点:
（1）都可以处理两个独立维度变化的问题。

（2）都可以替代多重继承。

不同点:
（1）装饰模式不能处理多维度变化问题，但桥接模式可以。

（2）被装饰过的对象可以被装饰多次，但桥接模式每个维度只能使用一次。

（3）未被装饰的对象可直接被客户端调用，但桥接模式一般调用的是多个维度的集合体。

### 分类

#### 透明装饰模式

要求客户端完全针对抽象编程，不应该把对象声明为具体构件类型或具体装饰类型，而应该全部声明为抽象构件类型。

对于客户端而言，具体构件对象和具体装饰对象没有任何区别;客户端可以透明使用装饰前后的对象，还可以对已装饰过的对象进行多次装饰。

要求具体装饰类的operation()方法覆盖抽象装饰类的operation()方法，除调用具体构件的operation()方法外，还需要调用新增的装饰方法。

设计难度较大，不利于单独调用新增的装饰方法。

#### 半透明装饰模式

使用具体装饰类定义装饰之后的对象，使用抽象构件类定义具体构件对象。

对于客户端来说，具体构件类型是透明的，具体装饰类型是不透明的。

给系统带来更多灵活性，设计相对简单，使用方便；但不能实现同一个对象的多次装饰，而且客户端需要区别对待装饰前后的对象。

### 注意事项

1.尽量使客户端可以一致对待装饰前后的对象，即使用透明装饰模式。

2.尽量向具体构件类中少放行为，用具体装饰类进行扩展。

3.如果只有一个具体构件类，则无须使用抽象构建类，抽象装饰类可直接作为具体构件类的子类。


### 应用

JavaIO的输入流和输出流设计，javax.swing包中一些图形界面构件功能的增强等。

### 优点

1.扩展一个对象功能时，比继承更加灵活，不会导致类的数量剧增。

2.可以通过配置文件选择具体装饰类，动态扩展对象的功能。

3.可以对一个对象进行多次装饰。

4.具体构件类和具体装饰类可以独立变化，增加具体构件类和具体装饰类时无须改变原有类库代码，符合“开闭原则”。

### 缺点

1.会产生很多连接方式不同的小对象，会占用系统资源，影响程序性能。

2.比继承更容易出错，排错困难，对于多次装饰的对象，找错比较繁琐。

### 适用场景

1.不影响其他对象时，以动态、透明的方式给单个对象添加职责。

2.当系统中有大量独立扩展且每种扩展的组合有大量子类/类被定义为final时。
