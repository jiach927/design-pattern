## 职责链模式 Chain of Responsibility Pattern

### 概述

职责链模式可以将请求的处理者组织成一条链，让请求沿着链传递，由链上的处理者对请求进行相应的处理。

客户端无须关心请求的处理细节和请求的传递，只需将请求发送到链上即可，实现请求发送者和请求处理者的解耦。

职责链可以是一条直线、一个环、一个树形结构，最常见的是一条直线。

### 定义

职责链模式避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。

职责链模式是一种对象行为型模式。

### 角色

1.Handler:抽象处理者，因为不同具体处理者处理请求的方式不同，所以定义抽象请求处理方法，因为每一位具体处理者的下家还是具体处理者，所以定义抽象处理者对象，作为对下家的引用。
```java
abstract class Handler{
    protected Handler successor;//维持对下家的引用
    public void setSuccessor(Handler successor){
        this.successor = successor;
    }
    public abstract void handleRequest(String request);
}
```
2.ConcreteHandler:具体处理者，抽象处理者子类，实现Handler定义的抽象请求处理方法，在处理请求前要判断是否有处理权限，若有则处理，若无则将请求转发给后继者。

具体处理者可以访问链中下一个对象，以便请求的转发。
```java
class ConcreteHandler extends Handler{
    public void handleRequest(String request){
        if(请求满足条件){/*处理请求*/}
        else{
            this.successor.handleRequest(request); //转发请求
        }
    }
}
```
3.Client:客户端，用于创造职责链。
```java
class Client{
    public static void main(String[] args){
        Handler h1,h2,h3;
        h1 = new ConcreteHandlerA();
        h2 = new ConcreteHandlerB();
        h3 = new ConcreteHandlerC();
        //创建职责链
        h1.setSuccessor(h2);
        h2.setSuccessor(h3);
    }
}
```

### 分类

#### 纯的职责链模式

1.要求具体处理者承担全部责任或把责任推给下家，不能承担一部分/全部责任后又把责任推给下家。

2.要求请求必须被某一个具体处理者对象接收和处理。

#### 不纯的职责链模式

1.允许请求被一个具体处理者部分处理后再向下传递。

2.允许具体处理者处理完请求后，后继处理者可以继续处理该请求。

3.请求可以不被任何具体处理者接收和处理。

eg.Java AWT 1.0的事件处理模型

有事件发生在窗口组件时，会通过组件对象的handleEvent()方法将事件传递给相应的事件处理方法，再决定是否向上一层容器组件传播；上层容器组件接收到事件后可以继续处理，然后决定是否继续向上层容器组件传播；直至顶层容器组件为止；若到顶层也没有处理方法，则事件不被处理。--事件浮生机制

### 优点

1.请求发送者无须知道哪个对象处理请求，请求接收者也不知道发送者的信息，职责链中的对象不知道链的结构（客户端创建），降低系统耦合度。

2.具体处理者只需维持对后继处理者的引用，简化对象的相互连接。

3.增加灵活性，可以在运行时对职责链进行动态增加或修改。

4.增加新的具体请求处理者无须修改源代码，若职责链中需要用到则客户端修改职责链即可，符合“开闭原则”。

### 缺点

1.请求可能因职责链配置不正确等原因未被处理。

2.对于比较长的职责链，请求的处理可能涉及多个具体处理对象，系统性能受到影响，调试代码不方便。

3.职责链设计不当会形成循环调用，系统陷入死循环。

### 适用场景

1.有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时确定。

2.在不明确接收者的情况下，向多个对象中的一个提交一个请求。

3.可动态指定一组对象处理请求，客户端可以创建职责链并改变链中处理者的顺序。